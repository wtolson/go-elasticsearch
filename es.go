// Go interface to elasticsearch.
package elasticsearch

import (
	"bytes"
	"encoding/json"
	"errors"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

var (
	ResponseError = errors.New("Response wasn't OK")
)

const (
	JSON_MIME = "application/json"
)

// Reference to an ElasticSearch server.
type ElasticSearch struct {
	client *http.Client
	host   string
}

type response struct {
	OK     bool                   `json:"ok"`
	Index  string                 `json:"_index"`
	Type   string                 `json:"_type"`
	Id     string                 `json:"_id"`
	Found  bool                   `json:"found"`
	Source map[string]interface{} `json:"_source"`
}

func NewElasticSearch(host string, maxConns int) *ElasticSearch {
	transport := &http.Transport{
		MaxIdleConnsPerHost: maxConns,
	}

	client := &http.Client{
		Transport: transport,
	}

	return &ElasticSearch{
		client: client,
		host:   host,
	}
}

func (es *ElasticSearch) url(parts ...string) *url.URL {
	return &url.URL{
		Scheme: "http",
		Host:   es.host,
		Path:   strings.Join(parts, "/"),
	}
}

func updateUrlQuery(u *url.URL, params map[string]string) {
	query := u.Query()
	for key, value := range params {
		query.Add(key, value)
	}
}

func handleResponse(resp *http.Response) (*response, error) {
	defer resp.Body.Close()

	if resp.StatusCode > 299 || resp.StatusCode < 200 {
		return nil, errors.New(resp.Status)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	data := &response{}

	err = json.Unmarshal(body, data)
	if err != nil {
		return nil, err
	}

	if !data.OK {
		return nil, ResponseError
	}

	return data, nil
}

func (es *ElasticSearch) post(u string, data interface{}) (*response, error) {
	body, err := json.Marshal(data)
	if err != nil {
		return nil, err
	}

	resp, err := es.client.Post(u, JSON_MIME, bytes.NewBuffer(body))
	if err != nil {
		return nil, err
	}

	return handleResponse(resp)
}

func (es *ElasticSearch) delete(u string) (*response, error) {
	req, err := http.NewRequest("DELETE", u, nil)
	if err != nil {
		return nil, err
	}

	resp, err := es.client.Do(req)
	if err != nil {
		return nil, err
	}

	return handleResponse(resp)
}

func (es *ElasticSearch) CreateIndex(index string, settings interface{},
	params map[string]string) error {

	u := es.url(index)
	updateUrlQuery(u, params)

	_, err := es.post(u.String(), settings)
	return err
}

// Store a document in the index.
//
// The ID is optional in which case the ID will be generated by the
// server.
//
// Returns the new ID on success, otherwise an error.
func (es *ElasticSearch) Index(index, doctype, id string,
	doc interface{}, params map[string]string) (string, error) {

	u := es.url(index, doctype, id)
	updateUrlQuery(u, params)

	resp, err := es.post(u.String(), doc)
	if err != nil {
		return "", err
	}

	return resp.Id, nil
}

// Delete an index entry.
func (es *ElasticSearch) Delete(index, doctype, id string,
	params map[string]string) (bool, error) {

	u := es.url(index, doctype, id)
	updateUrlQuery(u, params)

	resp, err := es.delete(u.String())
	if err != nil {
		return false, err
	}

	return resp.Found, nil
}
